Caesar Cipher (Static)

#include <stdio.h>
#include <string.h>

void caesarCipher(char text[], int shift) {
    int i;
    char ch;

  
    for (i = 0; text[i] != '\0'; ++i) {
	ch = text[i];


	if (isupper(ch)) {
	    ch = (ch + shift - 'A') % 26 + 'A';
	}

	else if (islower(ch)) {
	    ch = (ch + shift - 'a') % 26 + 'a';
	}

	text[i] = ch;
    }
}

int main() {
    char text[100];
    int shift = 3;  

    printf("Enter a string: ");
    fgets(text, sizeof(text), stdin);
    text[strcspn(text, "\n")] = '\0'; 

    caesarCipher(text, shift);

    printf("Encrypted string: %s\n", text);

    getch();  
    clrscr();

    return 0;
}

Caesar Cipher Decryption (Static)

#include <stdio.h>
#include <string.h>


void caesarDecrypt(char text[], int shift) {
    int i;
    char ch;

    for (i = 0; text[i] != '\0'; ++i) {
	ch = text[i];

	if (isupper(ch)) {
	    ch = (ch - shift - 'A' + 26) % 26 + 'A';
	} else if (islower(ch)) {
	    ch = (ch - shift - 'a' + 26) % 26 + 'a';
	}

	text[i] = ch;
    }
}

int main() {
    char text[100];
    int shift = 3;
    clrscr();

    printf("Enter the encrypted string: ");
    fgets(text, sizeof(text), stdin);
    text[strcspn(text, "\n")] = '\0';

    caesarDecrypt(text, shift);

    printf("Decrypted string: %s\n", text);

    getch();
    return 0;
}

///////////////////////////////////////////////////////////

Caesar Cipher (dynamic)

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <conio.h>  


void caesarCipher(char text[], int shift) {
    int i;
    char ch;

   
    for (i = 0; text[i] != '\0'; ++i) {
        ch = text[i];

       
        if (isupper(ch)) {
            ch = (ch + shift - 'A') % 26 + 'A';
        }
        // Encrypt lowercase letters
        else if (islower(ch)) {
            ch = (ch + shift - 'a') % 26 + 'a';
        }

        text[i] = ch;  
    }
}

int main() {
    char text[100];
    int shift;
   
    printf("Enter a string: ");
    fgets(text, sizeof(text), stdin);
    text[strcspn(text, "\n")] = '\0'; 

    printf("Enter shift value: ");
    scanf("%d", &shift);

    caesarCipher(text, shift);

    printf("Encrypted string: %s\n", text);
   
    getch();
    clrscr();

    return 0;
}

///////////////////////////////////////////////////////////

Playfair Encryption in C

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SIZE 30

void toLowerCase(char plain[], int ps) {
    int i;
    for (i = 0; i < ps; i++) {
        if (plain[i] > 64 && plain[i] < 91)
            plain[i] += 32;
    }
}

int removeSpaces(char* plain, int ps) {
    int i, count = 0;
    for (i = 0; i < ps; i++)
        if (plain[i] != ' ')
            plain[count++] = plain[i];
    plain[count] = '\0';
    return count;
}

void generateKeyTable(char key[], int ks, char keyT[5][5]) {
    int i, j, k, *dicty;

    dicty = (int*)calloc(26, sizeof(int));
    for (i = 0; i < ks; i++) {
        if (key[i] != 'j')
            dicty[key[i] - 97] = 2;
    }

    dicty['j' - 97] = 1;

    i = 0;
    j = 0;

    for (k = 0; k < ks; k++) {
        if (dicty[key[k] - 97] == 2) {
            dicty[key[k] - 97] -= 1;
            keyT[i][j] = key[k];
            j++;
            if (j == 5) {
                i++;
                j = 0;
            }
        }
    }

    for (k = 0; k < 26; k++) {
        if (dicty[k] == 0) {
            keyT[i][j] = (char)(k + 97);
            j++;
            if (j == 5) {
                i++;
                j = 0;
            }
        }
    }
}

void search(char keyT[5][5], char a, char b, int arr[]) {
    int i, j;

    if (a == 'j')
        a = 'i';
    else if (b == 'j')
        b = 'i';

    for (i = 0; i < 5; i++) {
        for (j = 0; j < 5; j++) {
            if (keyT[i][j] == a) {
                arr[0] = i;
                arr[1] = j;
            }
            else if (keyT[i][j] == b) {
                arr[2] = i;
                arr[3] = j;
            }
        }
    }
}

int mod5(int a) { return (a % 5); }

int prepare(char str[], int ptrs) {
    if (ptrs % 2 != 0) {
        str[ptrs++] = 'z'; 
        str[ptrs] = '\0';
    }
    return ptrs;
}

void encrypt(char str[], char keyT[5][5], int ps) {
    int i, a[4];

    for (i = 0; i < ps; i += 2) {
        search(keyT, str[i], str[i + 1], a);

        if (a[0] == a[2]) {
            str[i] = keyT[a[0]][mod5(a[1] + 1)];
            str[i + 1] = keyT[a[0]][mod5(a[3] + 1)];
        }
        else if (a[1] == a[3]) {
            str[i] = keyT[mod5(a[0] + 1)][a[1]];
            str[i + 1] = keyT[mod5(a[2] + 1)][a[1]];
        }
        else {
            str[i] = keyT[a[0]][a[3]];
            str[i + 1] = keyT[a[2]][a[1]];
        }
    }
}

void encryptByPlayfairCipher(char str[], char key[]) {
    char ps, ks, keyT[5][5];

    ks = strlen(key);
    ks = removeSpaces(key, ks);
    toLowerCase(key, ks);

    ps = strlen(str);
    toLowerCase(str, ps);
    ps = removeSpaces(str, ps);

    ps = prepare(str, ps);

    generateKeyTable(key, ks, keyT);

    encrypt(str, keyT, ps);
}

int main() {
    char str[SIZE], key[SIZE];
    clrscr();

    printf("Enter the key (no spaces): ");
    fgets(key, SIZE, stdin);
    key[strcspn(key, "\n")] = 0; 

    printf("Enter the plaintext (no spaces): ");
    fgets(str, SIZE, stdin);
    str[strcspn(str, "\n")] = 0; 

    encryptByPlayfairCipher(str, key);

    printf("Cipher text: %s\n", str);

    getch();
    return 0;
}

/////////////////////////////////////////////////////

Playfair Cipher Decryption in C

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SIZE 30

void toLowerCase(char plain[], int ps) {
    int i;
    for (i = 0; i < ps; i++) {
        if (plain[i] > 64 && plain[i] < 91)
            plain[i] += 32;
    }
}

int removeSpaces(char* plain, int ps) {
    int i, count = 0;
    for (i = 0; i < ps; i++)
        if (plain[i] != ' ')
            plain[count++] = plain[i];
    plain[count] = '\0';
    return count;
}

void generateKeyTable(char key[], int ks, char keyT[5][5]) {
    int i, j, k, *dicty;
    dicty = (int*)calloc(26, sizeof(int));

    for (i = 0; i < ks; i++) {
        if (key[i] != 'j')
            dicty[key[i] - 97] = 2;
    }
    dicty['j' - 97] = 1;

    i = 0;
    j = 0;

    for (k = 0; k < ks; k++) {
        if (dicty[key[k] - 97] == 2) {
            dicty[key[k] - 97] -= 1;
            keyT[i][j] = key[k];
            j++;
            if (j == 5) {
                i++;
                j = 0;
            }
        }
    }
    for (k = 0; k < 26; k++) {
        if (dicty[k] == 0) {
            keyT[i][j] = (char)(k + 97);
            j++;
            if (j == 5) {
                i++;
                j = 0;
            }
        }
    }
}

void search(char keyT[5][5], char a, char b, int arr[]) {
    int i, j;

    if (a == 'j')
        a = 'i';
    else if (b == 'j')
        b = 'i';

    for (i = 0; i < 5; i++) {
        for (j = 0; j < 5; j++) {
            if (keyT[i][j] == a) {
                arr[0] = i;
                arr[1] = j;
            } else if (keyT[i][j] == b) {
                arr[2] = i;
                arr[3] = j;
            }
        }
    }
}

int mod5(int a) {
    if (a < 0)
        a += 5;
    return (a % 5);
}

void decrypt(char str[], char keyT[5][5], int ps) {
    int i, a[4];
    for (i = 0; i < ps; i += 2) {
        search(keyT, str[i], str[i + 1], a);
        if (a[0] == a[2]) {
            str[i] = keyT[a[0]][mod5(a[1] - 1)];
            str[i + 1] = keyT[a[0]][mod5(a[3] - 1)];
        } else if (a[1] == a[3]) {
            str[i] = keyT[mod5(a[0] - 1)][a[1]];
            str[i + 1] = keyT[mod5(a[2] - 1)][a[1]];
        } else {
            str[i] = keyT[a[0]][a[3]];
            str[i + 1] = keyT[a[2]][a[1]];
        }
    }
}

void decryptByPlayfairCipher(char str[], char key[]) {
    char ps, ks, keyT[5][5];

    ks = strlen(key);
    ks = removeSpaces(key, ks);
    toLowerCase(key, ks);

    ps = strlen(str);
    toLowerCase(str, ps);
    ps = removeSpaces(str, ps);

    generateKeyTable(key, ks, keyT);
    decrypt(str, keyT, ps);
}

int main() {
    char str[SIZE], key[SIZE];
    clrscr();

    printf("Enter the key (no spaces): ");
    fgets(key, SIZE, stdin);
    key[strcspn(key, "\n")] = 0;

    printf("Enter the ciphertext (no spaces): ");
    fgets(str, SIZE, stdin);
    str[strcspn(str, "\n")] = 0;

    decryptByPlayfairCipher(str, key);
    printf("Deciphered text: %s\n", str);

    getch();
    return 0;
}

////////////////////////////////////////////////////////////////////////////

product cipher using Substitution ciphers and Transposition ciphers.

#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <ctype.h>

void substitutionCipher(const char *plaintext, char *result, int shift) {
    int i; 
    for (i = 0; plaintext[i] != '\0'; i++) {
        char c = plaintext[i];
        if (isupper(c)) {
            result[i] = ((c - 65 + shift) % 26) + 65;
        } else if (islower(c)) {
            result[i] = ((c - 97 + shift) % 26) + 97;
        } else {
            result[i] = c;
        }
    }
    result[i] = '\0';
} // (C-K) mod 26 brute force

void transpositionCipher(const char *plaintext, char *result, int key) {
    int n = strlen(plaintext);
    char rail[10][100];
    int row = 0, col = 0;
    int direction_down = 0;
    int i, j;
    int index = 0;

    for (i = 0; i < key; i++) {
	for (j = 0; j < n; j++) {
	    rail[i][j] = '\n';
	}
    }

    for (i = 0; i < n; i++) {
	if (row == 0 || row == key - 1) {
	    direction_down = !direction_down;
	}

	rail[row][col++] = plaintext[i];

	if (direction_down) {
	    row++;
	} else {
	    row--;
	}
    }

	for (i = 0; i < key; i++) {
	for (j = 0; j < n; j++) {
	    if (rail[i][j] != '\n') {
		result[index++] = rail[i][j];
            }
        }
    }
    result[index] = '\0';
}

void productCipher(const char *plaintext, char *result, int shift, int transpositionKey) {
    char substitutionResult[100];
    substitutionCipher(plaintext, substitutionResult, shift);
    transpositionCipher(substitutionResult, result, transpositionKey);
}

int main() {
    char plaintext[100], encryptedText[100];
    int shift = 4;
    int transpositionKey = 3;

    clrscr();

    printf("Enter the original text: ");
    gets(plaintext);

    productCipher(plaintext, encryptedText, shift, transpositionKey);

    printf("Original Text: %s\n", plaintext);
    printf("Encrypted Text: %s\n", encryptedText);

    getch(); 
    return 0;
}

///////////////////////////////////////////////////////////////////////////////////

demonstrate integrity management by implementing message digest using MD5. (PYHTON)

import hashlib

def generate_md5_hash(input_string):
    # Create an MD5 hash object
    md5_hash = hashlib.md5()
    
    # Update the hash object with the bytes of the input string
    md5_hash.update(input_string.encode('utf-8'))
    
    # Get the hexadecimal representation of the hash
    return md5_hash.hexdigest()

def main():
    # Take input from the user
    message = input("Enter a message to hash: ")
    
    # Generate MD5 hash
    md5_hash = generate_md5_hash(message)
    
    # Print the MD5 hash
    print("MD5 Hash:", md5_hash)

if __name__ == "__main__":
    main()

///////////////////////////////////////////////////////////////////////////////////////

Implementation and analysis of RSA cryptosystem and Digital signature scheme using RSA.

import random

# Helper function to calculate gcd
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

# Primality test (Miller-Rabin)
def is_prime(n, k=40):  # k is the number of rounds
    if n == 2 or n == 3:
        return True
    if n <= 1 or n % 2 == 0:
        return False
    # Write (n - 1) as 2^r * d
    r, d = 0, n - 1
    while d % 2 == 0:
        r += 1
        d //= 2
    # Witness loop
    for _ in range(k):
        a = random.randint(2, n - 2)
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(r - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True

# Extended Euclidean Algorithm to find modular inverse
def mod_inverse(e, phi):
    def extended_gcd(a, b):
        if a == 0:
            return b, 0, 1
        gcd, x1, y1 = extended_gcd(b % a, a)
        x = y1 - (b // a) * x1
        y = x1
        return gcd, x, y
    
    gcd, x, y = extended_gcd(e, phi)
    if gcd != 1:
        raise Exception('Modular inverse does not exist')
    else:
        return x % phi

# RSA Key Generation
def generate_rsa_keys(bits=1024):
    # Generating two large prime numbers p and q
    p = generate_prime_number(bits // 2)
    q = generate_prime_number(bits // 2)
    
    n = p * q
    phi_n = (p - 1) * (q - 1)
    
    e = 65537  # Common choice for e
    d = mod_inverse(e, phi_n)
    
    return (e, n), (d, n)

# Generate large prime number
def generate_prime_number(length=1024):
    p = 4
    while not is_prime(p):
        p = random.getrandbits(length)
    return p

# RSA Encryption
def rsa_encrypt(public_key, plaintext):
    e, n = public_key
    plaintext_int = int.from_bytes(plaintext.encode('utf-8'), byteorder='big')
    ciphertext = pow(plaintext_int, e, n)
    return ciphertext

# RSA Decryption
def rsa_decrypt(private_key, ciphertext):
    d, n = private_key
    decrypted_int = pow(ciphertext, d, n)
    decrypted_bytes = decrypted_int.to_bytes((decrypted_int.bit_length() + 7) // 8, byteorder='big')
    return decrypted_bytes.decode('utf-8')

# RSA Signature Generation
def rsa_sign(private_key, message):
    d, n = private_key
    message_int = int.from_bytes(message.encode('utf-8'), byteorder='big')
    signature = pow(message_int, d, n)
    return signature

# RSA Signature Verification
def rsa_verify(public_key, message, signature):
    e, n = public_key
    verified_int = pow(signature, e, n)
    verified_bytes = verified_int.to_bytes((verified_int.bit_length() + 7) // 8, byteorder='big')
    return verified_bytes.decode('utf-8') == message

# Example usage
public_key, private_key = generate_rsa_keys()

message = "Hello, RSA!"

# Encryption and Decryption
ciphertext = rsa_encrypt(public_key, message)
print(f"Ciphertext: {ciphertext}")

decrypted_message = rsa_decrypt(private_key, ciphertext)
print(f"Decrypted Message: {decrypted_message}")

# Digital Signature
signature = rsa_sign(private_key, message)
print(f"Signature: {signature}")

is_valid = rsa_verify(public_key, message, signature)
print(f"Signature valid: {is_valid}")

///////////////////////////////////////////////////////////////////////////////

nmap
Linux  { sudo apt update
sudo apt install nmap }

Windows { https://nmap.org/download.html }

1. Scan for Open Ports
To scan the most common 1000 TCP ports on a specific host:
nmap 192.168.1.1

2. TCP Connect Scan
A TCP connect scan performs a full connection (useful when you don’t have root privileges):
nmap -sT 192.168.1.1

3. SYN Scan (Stealth Scan)
This is the most popular scan option and is the default for root users on Linux:
sudo nmap -sS 192.168.1.1  # Ubuntu (requires sudo)
nmap -sS 192.168.1.1        # Windows (run as Administrator)

4. UDP Scan
To scan for open UDP ports (which can take longer than TCP):
sudo nmap -sU 192.168.1.1  # Ubuntu (requires sudo)
nmap -sU 192.168.1.1        # Windows (run as Administrator)

5. Ping Scan
To check whether a host is alive (online), use a ping scan:
nmap -sn 192.168.1.0/24
This will ping all hosts in the subnet 192.168.1.0/24 and return a list of hosts that are up.

6. OS Fingerprinting
To detect the operating system running on a target machine:
sudo nmap -O 192.168.1.1  # Ubuntu (requires sudo)
nmap -O 192.168.1.1        # Windows (run as Administrator)

7. Service Version Detection
To detect versions of services running on the target:
nmap -sV 192.168.1.1

8. Scan Specific Ports
To scan a specific port (or range of ports):
nmap -p 80,443 192.168.1.1     # Scan port 80 and 443
nmap -p 1-100 192.168.1.1      # Scan ports 1 through 100

9. Aggressive Scan
This combines OS detection, version detection, and traceroute in a single command:
sudo nmap -A 192.168.1.1  # Ubuntu (requires sudo)
nmap -A 192.168.1.1        # Windows (run as Administrator)

10. Scan a Subnet
To scan all devices on a subnet (e.g., 192.168.1.0/24):
nmap 192.168.1.0/24

11. Scan All TCP Ports
To scan all 65535 TCP ports:
sudo nmap -p- 192.168.1.1  # Ubuntu (requires sudo)
nmap -p- 192.168.1.1        # Windows (run as Administrator)

12. Disable Host Discovery (Scan All Ports Even if Host Doesn’t Respond)
To scan all ports of a host even if it doesn’t respond to pings:
sudo nmap -Pn 192.168.1.1  # Ubuntu (requires sudo)
nmap -Pn 192.168.1.1        # Windows (run as Administrator)

13. Save Output to a File
To save the results of a scan to a file:
nmap -oN scan_results.txt 192.168.1.1  # Normal output to a text file
nmap -oX scan_results.xml 192.168.1.1  # Output in XML format














